<!DOCTYPE html>
<html lang="pl">

<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
    <link href="style.css" rel=stylesheet type="text/css">
</head>

<body>
    <header class="header-navigation">
        <nav class="navigation">
            <a class="navigation-link" href="index.html">Strona główna</a>
            <a class="navigation-link" href="nauka_html.html">HTML</a>
            <a class="navigation-link" href="nauka_css.html">CSS</a>
            <a class="navigation-link" href="JavaScript.html">JavaScript</a>
        </nav>
    </header>

    <main>
        <header class="JS">
            <h1>Notatki z JavaScript</h1>
        </header>

        <div class="row">
            <section class="notes-section">
                <h2 class="notes-JavaScript--js">Tu jest przykładowy element</h2>
                <p>
                <ul>
                    <li>alert('tekst'); - na stronie (przed jej załadowaniem) wyświetli się alert</li></br>
                    <li>console.log('tekst'); - pojawia się napis w konsoli</li></br>
                    <li>const nazwa_zmiennej = 'tekst'; - sposób zapisu zmiennej</li></br>
                    <li>const nazwa_zmiennej = liczba; - sposób zapisuj zmiennej z liczbą</li></br>
                    <li>console.log(nazwa_zmiennej); - sposób wywołania zmiennej</li></br>
                    <li>console.log(`tekst + ${zmienne}`); - zapis literału, czyli tekstu wraz ze zmiennymi; zamiast
                    <li>pojedynczego cudzysłowu(') używamy tyldy (`)</li></br>
                    <li>let nazwa_zmiennej = 'tekst' - tworzymy zmienną, którą możemy potem nadpisać</li></br>
                    <li>typeof - sprawdza jakiego typu jest dana zmienna</li></br>
                </ul>
                </p>
            </section>
        </div>

        <div class="row">
            <section class="notes-section">
                <p>
                <h2>Zmienne</h2>
                Istnieją trzy sposoby zapisywania zmiennych w JavaScript. Są to słowa kluczowe LET, CONST i VAR.
                Powoli odchodzi się od używania VAR.
                </p>
            </section>
        </div>

        <div class="row">
            <section class="notes-section">
                <p>
                <h2>Funkcje</h2>
                function calculate(myNumber) { return myNumber*7; }</br>
                <p></p>
                function - deklaracja </br>
                (myNumber) - parametr </br>
                return - słowo kluczowe </br>
                myNumber - wynik </br>
                </p>
                <p>
                    Aby wpisać parametry w funckję:</br>
                    calculate();</br>
                    calculate - nazwa funkcji,którą chcemy wywołać</br>
                    W nawiasie wpisujemy parametr, który "wskoczy" w miejsce myNumber. Dzięki temu funkcja będzie
                    mogła przeprowadzić działanie.</br>
                </p>
                <p>
                    W celu wywołania funkcji w konsoli najpierw musimy przypisać zmienną do calculate():</br>
                    const myResult = calculate();</br>
                    Aby wyświetlić wynik funkcji w konsoli należy wpisać:</br>
                    console.log(myResult)
                </p>
                <p>
                    W funckjack JS możemy wpisywać nie tylko liczny ale też tekst. Funkcja może również pryzjmować
                    więcej nić jeden parametr.</br>
                    Przykładowa funkcja:</br>
                <p></p>
                function greet (age,firstName) {</br>
                console.log(</br>
                `Witaj Drogi Odwiedzający, nazywam się %{firstName} i mam ${age} lat.`</br>
                );</br>
                };</br>
                </p>
                Podstawiamy paramatery:</br>
                greet(18,'Maciek')</br>
                Funkcja wywoła zdanie w konsoli nawet bez returna:</br>
                "Witaj Drogi Odwiedzający, nazywam się <strong>Maciek</strong> i mam <strong>18</strong> lat."</br>
                W przypadku nie podania, któregoś z elementów pojawi się na jego miejscu "undefined".</br>
                Możemy wywołać jedną funkcję wiele razy.</br>
                <p>
                    Poniżej przykład funkcji za pomocą której, możemy uzupełnić wybrany element HTML o określony
                    content.
                <p></p>
                function createContent(querySelectorContent,content) {</br>
                const element = document.querySelector(querySelectorContent);</br>
                element.innerHTML = content;</br>
                }</br>
                Wywołujemy funkcję:</br>
                createContent('.week-summary__description--js', 'Witaj świecie!')</br>
                <p></p>
                Rezultat:</br>
                W miejscu wskazany przez querySelectorContent pojawia się wpisany przez nas content.</br>
                </p>
                <p>
                    Podsumowanie:</br>
                <p></p>
                Deklarujemy nazwę funkcji (nie zawsze).</br>
                W środku dokonujemy obliczeń/wykonujemy zadania.</br>
                Funkcja przyjmuje argumenty (ale nie musi).</br>
                Funkacja zwraca zawsze coś (nawet jeśli nie mamy return - wtedy funkcja zwraca undefined)
                </p>
            </section>
        </div>

        <div class="row">
            <section class="notes-section">
                <p>
                <h2>(Fat) arrow function</h2>
                Przykład arrow function:</br>
                <p></p>
                cont calculate = (myNumber) => {</br>
                myNumber = myNumber + 3;</br>
                console.log(myNumber);</br>
                return myNumber*7;</br>
                }</br>
                <p></p>
                calculate(2); //35</br>
                <p></p>
                Funkcja greet w wersji fat arrow:</br>
                const greet = (age,firstName) => {
                console.log(</br>
                `Witaj Drogi Odwiedzający, nazywam się %{firstName} i mam ${age} lat.`</br>
                );</br>
                }</br>
                <p></p>
                Można skrócić jeszcze bardziej:</br>
                const calculate = myNumber => (myNumber+3)*7;</br>
                const myResult = calculate(7)</br>
                console.log(myResult)</br>
                <p></p>
                Podsumowanie:</br>
                Skraca zapis deklaracji funkcji.</br>
                Zawiększa czytelność (dyskusyjne).</br>
                Nie tworzy nowego kontekstu <strong>this</strong>, nie ma dostępu do <strong>arguments</strong> i
                <strong>super</strong>.</br>
                Nie jest zamiennikiem "tradycyjnej" funkcji (ale w większości przypadków nie zobaczysz różnicy).</br>
                </p>
            </section>
        </div>

        <div class="row">
            <section class="notes-section">
                <p>
                <h2>Obiekty</h2>
                Obiekt jest strukturą danych.</br>
                Przykład obiektu:</br>
                <p></p>
                const deathStar = {</br>
                diameter: 120000,</br>
                fire: (target) => {</br>
                console.log(`${target} destroyed 💥`)</br>
                },</br>
                isOperating: true,</br>
                levels: 357,</br>
                name: 'Death Star',</br>
                population: 10000,</br>
                }</br>
                Funkcje określają jakąś czynność a obiekt zawiera infomracje o jego cechach.</br>
                Obiekt może zawierać w sobie funkcje.</br>
                W konsoli własności obiektu wypisywane są alfabetycznie.</br>
                <p></p>
                klucz: wartość;</br>
                klucz - unikalny w ramach obiektu</br>
                wartość - prymitywy / funkcje / zagnieżdżenia</br>
                <p></p>
                Możliwe jest stworzenie obiektu w obiekcie.</br>
                <p></p>
                Aby wypisać jedną własność z obiektu:</br>
                console.log(deathStar.name)</br>
                Konsola wypisze nam tylko własność name.</br>
                Jeśli chcemy przejśc do własności obiektu w obiekcie doapisujemy kolejną kropkę a po niej nazwę
                własności:</br>
                console.log(deathStar.commander.name)</br>
                <p></p>
                Metodą w obiektach nazywamy funkcję w tym obiekcie.</br>
                Metodę wywołujemy w nasyępujący sposób:</br>
                deathStar.fire('Rebel ship')</br>
                fire - nazwa metody</br>
                () - w nawiasie wpisujemy target zapisany w metodzie fire</br>
                <p></p>
                Oprócz metody dot notation (zaprezentowanej powyżej) istnieje również bracket notation.</br>
                Wygląda ona natępująco:</br>
                <p></p>
                console.log(deathStar['name'])</br>
                <p></p>
                W metodzie bracket podając własność konieczne jest użycie kwadratowych nawiasów.</br>
                <p></p>
                Funkcja,która pozwala na szybkie wywoływanie własności z obiektu:</br>
                <p></p>
                const showMeProperty = (myProperty) => {</br>
                console.log(`Twoje własność ${myProperty} to: ${deathStar[myProperty]}`);</br>
                }</br>
                <p></p>
                showMeProperty('levels')</br>
                Funkcja wypisze własność levels obiektu deathStar.</br>
                </p>
            </section>
        </div>

        <div class="row">
            <section class="notes-section">
                <p>
                <h2>Immutability w obiektach</h2>
                Nie da się usunąć wartości ze zmiennych. My jest tylko przekierowujemy.</br>
                Jeśli mamy dwa consty albo lety o tej samej wartości,to są one czymś oddzielnym. Oba są podłaczone
                do tej samej wartości. Np.:</br>
                const humanOne = 'Wojtek'</br>
                const humanTwo = 'Wojtek'</br>
                Zarówno humanOne jak i humanTwo są podłączone do tego samego Wojtka. Nie ma dwóch odzielnych
                Wojtków.</br>
                WAŻNE!</br>
                Typy proste są niemutowalne. Natomiast obiekty są mutowalne. Np.:</br>
                const humanOne = {</br>
                name = 'Wojtek',</br>
                age = 25</br>
                }</br>
                <p></p>
                const humanTwo = {</br>
                name = 'Anna',</br>
                age = 26</br>
                }</br>
                <p></p>
                Możemy zmienić włsności obiektu. Nie są one stałe. Czyli np. możemy przypisać Annie wiek 25. Wtedy
                podepnie się
                on w naszym świecie wartości do 25-tki. Tej samej, do której jest podłączony Wojtek.</br>
                Możemy też zrobić to w drugą stronę. Jeśli obie własności age wynosiłyby 25 możemy ustawić jedną z nich
                na inną
                liczbę,ponieważ te połączenia są elastyczne.</br>
                <p></p>
                Możemy również przypisać obiektowi humanTwo własności obiektu humanOne. Wtedy własności humanOne stają
                się wartościami
                humanTwo. Jednak jeśli zmienimyy wartości własności w humanTwo zostaną one również zmienione dla
                humanOne.
                Jeśli zmienimy age w humanTwo, age w humanOne również ulegnie zmianie.</br>
                </p>
            </section>
        </div>

        <div class="row">
            <section class="notes-section">
                <p>
                <h2>Warto zapamiętać</h2>
                <ul>
                    <li>Zmianna to nie wartość!</li></br>
                    <li>Kod script dodajemy na samym końcu HTML-a (za footerem a przed body)</li></br>
                    <li>Pmiętaj o kolejności zapisów w JS!</li></br>
                    <li>Zmienna to połączenie z naszym wszechświatem wartości</li></br>
                    <li>Nie możemy zmieniać wartości primitive values w JS. To co zmieniamy to połączenie między nimi, a
                        zmiennymi.</li></br>
                    <li>Jeśli funkcja nie ma zdefiniowanego returna to zwróci nam undefined.</li></br>
                    <li>Warto pamiętać,że w JS wszystko opiera się na połączeniach a nie na wartościach.</li></br>
                </ul>
                </p>
            </section>
        </div>

    </main>
    <footer>
        <h3 class="footer">Strona do <a class="footer-link" href="#notatki">notatek</a> z kursu WTF:Co ten Frontend.
        </h3>
    </footer>
    <script src="main.js"></script>

</body>

</html>